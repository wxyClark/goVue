<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>JavaScript异步编程 - 前端学习路径</title>
    <link rel="stylesheet" href="../css/main.css">
</head>
<body>
    <!-- 导入头部 -->

    <div class="container">
        <div class="main-content">
            <h1>JavaScript异步编程</h1>
            
            <h2>异步编程概述</h2>
            <p>JavaScript是单线程语言，异步编程是JavaScript处理耗时操作的核心机制，它允许程序在执行耗时操作（如网络请求、文件读取）时不会阻塞主线程。</p>
            
            <div class="example">
                <h3>同步 vs 异步</h3>
                <table>
                    <tr>
                        <th>同步编程</th>
                        <th>异步编程</th>
                    </tr>
                    <tr>
                        <td>代码按顺序执行，前一个任务完成后才会执行下一个任务</td>
                        <td>代码不按顺序执行，耗时任务在后台执行，完成后通知主线程</td>
                    </tr>
                    <tr>
                        <td>会阻塞主线程</td>
                        <td>不会阻塞主线程</td>
                    </tr>
                    <tr>
                        <td>适合简单的、快速完成的任务</td>
                        <td>适合耗时的任务，如网络请求、文件操作</td>
                    </tr>
                    <tr>
                        <td>示例：基本的数学运算、变量赋值</td>
                        <td>示例：AJAX请求、定时器、事件处理</td>
                    </tr>
                </table>
            </div>
            
            <h2>回调函数（Callback）</h2>
            <p>回调函数是异步编程的最基本形式，它是一个作为参数传递给另一个函数的函数，在异步操作完成后被调用。</p>
            
            <div class="example">
                <h3>回调函数的基本使用</h3>
                <div class="code">
// 模拟异步操作
function fetchData(url, callback) {
    setTimeout(() => {
        // 模拟网络请求返回数据
        const data = { id: 1, name: '张三', age: 30 };
        // 调用回调函数，将数据传递给它
        callback(null, data);
    }, 1000);
}

// 使用回调函数
fetchData('https://api.example.com/users', function(error, data) {
    if (error) {
        console.error('请求失败:', error);
        return;
    }
    console.log('请求成功，数据:', data);
});
                </div>
                <div class="demo-area">
                    <button id="callback-demo-btn" class="demo-button">运行回调函数示例</button>
                    <div id="callback-log" class="log"></div>
                </div>
            </div>
            
            <div class="example">
                <h3>回调地狱（Callback Hell）</h3>
                <p>当有多个异步操作需要按顺序执行时，回调函数会嵌套在一起，形成所谓的"回调地狱"，使代码难以阅读和维护。</p>
                <div class="code">
// 回调地狱示例
fetchUser(id, function(error, user) {
    if (error) return console.error(error);
    
    fetchPosts(user.id, function(error, posts) {
        if (error) return console.error(error);
        
        fetchComments(posts[0].id, function(error, comments) {
            if (error) return console.error(error);
            
            fetchAuthor(comments[0].authorId, function(error, author) {
                if (error) return console.error(error);
                
                console.log('作者信息:', author);
            });
        });
    });
});
                </div>
            </div>
            
            <h2>Promise</h2>
            <p>Promise是ES6引入的异步编程解决方案，它代表一个异步操作的最终完成（或失败）及其结果值。</p>
            
            <div class="example">
                <h3>Promise的基本概念</h3>
                <p>Promise有三种状态：</p>
                <ul>
                    <li><strong>pending（待定）</strong>：初始状态，既没有被兑现，也没有被拒绝</li>
                    <li><strong>fulfilled（已兑现）</strong>：操作成功完成</li>
                    <li><strong>rejected（已拒绝）</strong>：操作失败</li>
                </ul>
            </div>
            
            <div class="example">
                <h3>创建Promise</h3>
                <div class="code">
// 创建Promise
const promise = new Promise(function(resolve, reject) {
    setTimeout(() => {
        const success = true;
        if (success) {
            // 操作成功，调用resolve
            resolve('操作成功完成');
        } else {
            // 操作失败，调用reject
            reject('操作失败');
        }
    }, 1000);
});

// 使用Promise
promise
    .then(function(result) {
        console.log('成功:', result);
    })
    .catch(function(error) {
        console.error('失败:', error);
    })
    .finally(function() {
        console.log('无论成功或失败都会执行');
    });
                </div>
                <div class="demo-area">
                    <button id="promise-demo-btn" class="demo-button">运行Promise示例</button>
                    <div id="promise-log" class="log"></div>
                </div>
            </div>
            
            <div class="example">
                <h3>Promise链式调用</h3>
                <p>Promise的then方法可以返回一个新的Promise，从而实现链式调用，避免回调地狱。</p>
                <div class="code">
// 链式调用示例
fetchUser(id)
    .then(function(user) {
        console.log('用户信息:', user);
        return fetchPosts(user.id);
    })
    .then(function(posts) {
        console.log('用户帖子:', posts);
        return fetchComments(posts[0].id);
    })
    .then(function(comments) {
        console.log('帖子评论:', comments);
        return fetchAuthor(comments[0].authorId);
    })
    .then(function(author) {
        console.log('作者信息:', author);
    })
    .catch(function(error) {
        console.error('发生错误:', error);
    });
                </div>
                <div class="demo-area">
                    <button id="promise-chain-demo-btn" class="demo-button">运行Promise链式调用示例</button>
                    <div id="promise-chain-log" class="log"></div>
                    <div id="promise-chain-steps" class="process"></div>
                </div>
            </div>
            
            <div class="example">
                <h3>Promise的静态方法</h3>
                <div class="code">
// Promise.all - 并行执行多个Promise，全部成功才成功
const promise1 = fetchData(1);
const promise2 = fetchData(2);
const promise3 = fetchData(3);

Promise.all([promise1, promise2, promise3])
    .then(function(results) {
        console.log('所有Promise都成功:', results);
    })
    .catch(function(error) {
        console.error('至少有一个Promise失败:', error);
    });

// Promise.race - 多个Promise中第一个完成的结果
Promise.race([promise1, promise2, promise3])
    .then(function(result) {
        console.log('第一个完成的Promise结果:', result);
    });

// Promise.allSettled - 所有Promise都完成（无论成功或失败）
Promise.allSettled([promise1, promise2, promise3])
    .then(function(results) {
        console.log('所有Promise的结果:', results);
    });

// Promise.resolve - 创建一个已兑现的Promise
Promise.resolve('成功的结果').then(console.log);

// Promise.reject - 创建一个已拒绝的Promise
Promise.reject('失败的原因').catch(console.error);
                </div>
                <div class="demo-area">
                    <button id="promise-static-demo-btn" class="demo-button">运行Promise静态方法示例</button>
                    <div id="promise-static-log" class="log"></div>
                </div>
            </div>
            
            <h2>async/await</h2>
            <p>async/await是ES2017引入的语法糖，它基于Promise，使异步代码看起来更像同步代码，提高了可读性和可维护性。</p>
            
            <div class="example">
                <h3>async/await的基本使用</h3>
                <div class="code">
// async函数
async function fetchData() {
    try {
        // 使用await等待Promise完成
        const user = await fetchUser(id);
        console.log('用户信息:', user);
        
        const posts = await fetchPosts(user.id);
        console.log('用户帖子:', posts);
        
        const comments = await fetchComments(posts[0].id);
        console.log('帖子评论:', comments);
        
        const author = await fetchAuthor(comments[0].authorId);
        console.log('作者信息:', author);
        
        return author;
    } catch (error) {
        // 处理错误
        console.error('发生错误:', error);
        throw error;
    }
}

// 调用async函数
fetchData()
    .then(function(result) {
        console.log('最终结果:', result);
    })
    .catch(function(error) {
        console.error('调用失败:', error);
    });
                </div>
                <div class="demo-area">
                    <button id="async-await-demo-btn" class="demo-button">运行async/await示例</button>
                    <div id="async-await-log" class="log"></div>
                    <div id="async-await-steps" class="process"></div>
                </div>
            </div>
            
            <div class="example">
                <h3>async/await并行处理</h3>
                <p>使用Promise.all配合async/await可以实现并行处理多个异步操作。</p>
                <div class="code">
async function fetchMultipleData() {
    try {
        // 并行执行多个异步操作
        const [user, posts, comments] = await Promise.all([
            fetchUser(id),
            fetchPosts(id),
            fetchComments(id)
        ]);
        
        console.log('用户信息:', user);
        console.log('用户帖子:', posts);
        console.log('帖子评论:', comments);
        
        return { user, posts, comments };
    } catch (error) {
        console.error('发生错误:', error);
    }
}

fetchMultipleData();
                </div>
                <div class="demo-area">
                    <button id="async-parallel-demo-btn" class="demo-button">运行async/await并行处理示例</button>
                    <div id="async-parallel-log" class="log"></div>
                </div>
            </div>
            
            <h2>实际应用示例</h2>
            <p>以下是异步编程在实际开发中的应用示例：</p>
            
            <div class="example">
                <h3>1. 异步数据加载</h3>
                <div class="code">
// 使用async/await加载数据
async function loadUserData(userId) {
    try {
        // 模拟API请求
        const response = await fetch(`https://jsonplaceholder.typicode.com/users/${userId}`);
        if (!response.ok) {
            throw new Error('网络响应失败');
        }
        const user = await response.json();
        
        // 加载用户的帖子
        const postsResponse = await fetch(`https://jsonplaceholder.typicode.com/posts?userId=${user.id}`);
        const posts = await postsResponse.json();
        
        return { user, posts };
    } catch (error) {
        console.error('加载用户数据失败:', error);
        throw error;
    }
}

// 使用数据
loadUserData(1)
    .then(data => {
        document.getElementById('user-info').innerHTML = `
            <h3>${data.user.name}</h3>
            <p>邮箱: ${data.user.email}</p>
            <p>地址: ${data.user.address.street}, ${data.user.address.city}</p>
        `;
        
        const postsList = data.posts.map(post => 
            `<li><strong>${post.title}</strong><p>${post.body}</p></li>`
        ).join('');
        document.getElementById('user-posts').innerHTML = `<ul>${postsList}</ul>`;
    });
                </div>
            </div>
            
            <div class="example">
                <h3>2. 文件上传处理</h3>
                <div class="code">
// 文件上传处理
async function uploadFile(file) {
    try {
        const formData = new FormData();
        formData.append('file', file);
        
        const response = await fetch('/api/upload', {
            method: 'POST',
            body: formData
        });
        
        if (!response.ok) {
            throw new Error('文件上传失败');
        }
        
        const result = await response.json();
        return result;
    } catch (error) {
        console.error('文件上传错误:', error);
        throw error;
    }
}

// 监听文件上传
const fileInput = document.getElementById('file-upload');
fileInput.addEventListener('change', async (event) => {
    const file = event.target.files[0];
    if (file) {
        try {
            const result = await uploadFile(file);
            console.log('文件上传成功:', result);
        } catch (error) {
            console.error('文件上传失败:', error);
        }
    }
});
                </div>
            </div>
        </div>
    </div>
    
    <!-- 演示脚本 -->
    <script src="../js/async-programming_2.js"></script>
</body>
</html>